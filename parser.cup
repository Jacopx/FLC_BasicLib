import java_cup.runtime.*;
import java.io.*;
import java.util.HashMap;
import java.util.Vector;
import java.util.Collections;

init with {:
    sym = new HashMap();
:};

parser code {:

    public HashMap sym;

    public boolean isCorrect = true;

    // Redefinition of error functions
    /* The report_error function, in this program, is called only when
       an error, not managed by the error symbol, is found.
       Indeed, when errors are recognized by the error symbol, the function
       syntax_error (disabled in this program) is called.
       This program is an example of error function redefinition: two new
       functions are developed, pSynError and pSynWarning, used to print
       syntactical errors and warning, respectively. */
    public void report_error(String message, Object info) {
        System.err.print("ERROR: Syntax error");
        if (info instanceof Symbol)
            if (((Symbol)info).left != -1){
                int line = (((Symbol)info).left)+1;
                int column = (((Symbol)info).right)+1;
                System.err.print(" (linea "+line+", colonna "+column+"): ");
            } else System.err.print(": ");
        else System.err.print(": ");
    }

    public void syntax_error(Symbol cur_token){}

      // Return actual symbol
      public Symbol getToken() {
          return ((Symbol)stack.elementAt(tos));
      }

      // Return semantic value of symbol in position (position)
      public Object stack(int position) {
          return (((Symbol)stack.elementAt(tos+position)).value);
      }

    // Return semantic value of symbol in position (position)
      public void setStack(int position, Object val) {
          ((Symbol)stack.elementAt(tos+position)).value = val;
      }

        // Return the line number of actual symbol
    public int getLine() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).left+1;
        }else return -1;
    }
    // Return the column number of actual symbol
    public int getColumn() {
        if (((Symbol)stack.elementAt(tos)).left != -1){
            return ((Symbol)stack.elementAt(tos)).right+1;
        }else return -1;
    }


    :};


action code {:

    private void pSynError(String message){
        System.err.println("SYN ERROR: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);
        parser.isCorrect = false;
        parser.done_parsing();
    }
    private void pSynWarning(String message){
        System.err.println("SYN WARNING: line: "+parser.getLine()+" col: "+parser.getColumn()+": "+message);
        parser.isCorrect = false;
    }

    private Boolean compareObj(Object a, Object b) {
      if(a instanceof Boolean) {
        return (Boolean) a != (Boolean) b;
      } else {
        return (Double.parseDouble(a.toString()) != Double.parseDouble(b.toString()));
      }
    }

    private String min(HashMap h) {
      return Collections.min(h.values()).toString();
    }
    private String max(HashMap h) {
      return Collections.max(h.values()).toString();
    }

:}


// Terminal tokens
terminal Integer INT;
terminal Double DOUBLE;

terminal WHILE, ELSE;
terminal ID;
terminal DATE;
terminal RO, RC, BO, BC, S, CM, SO, SC;
terminal PLUS, MINUS, STAR, DIV;
terminal MIN, MAJ, MIN_EQ, EQ_MIN, MAJ_EQ, EQ_MAJ, EQ;
terminal AND, ANDAND, NOTEQ, OR, OROR, NOT;
terminal INT_TYPE, DOUBLE_TYPE;
terminal UMINUS;
terminal START, STATE, DONE, CASE, NEW, FI, IF, PRINT, DO, DOT, ESSE;
terminal String LETTERS;


// Non terminal tokens
non terminal prog;
non terminal missing_non_term;

non terminal String stmt_list, stmt;
non terminal Object exp;
non terminal Object id;

//////////////////////////////////////
// Grammar start
//////////////////////////////////////

start with prog;


prog ::= missing_non_term {: if (parser.isCorrect) System.out.println("Program correctly recognized"); :}
;
